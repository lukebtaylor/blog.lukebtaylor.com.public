<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c# on Luke's blog site</title><link>https://blog.lukebtaylor.com/categories/c#/</link><description>Recent content in c# on Luke's blog site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 21 Jul 2016 22:11:44 -0600</lastBuildDate><atom:link href="https://blog.lukebtaylor.com/categories/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>C# - Get All Active Directory Users in a Group</title><link>https://blog.lukebtaylor.com/posts/c#-get-all-active-directory-users-in-group/</link><pubDate>Thu, 21 Jul 2016 22:11:44 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/c#-get-all-active-directory-users-in-group/</guid><description>Use the following handy method to get all users in an AD group .NET 3.5
Add a reference to
System.DirectoryServices.AccountManagement public static List&amp;lt;UserPrincipal&amp;gt; GetAllUsersInGroup(string domain, string groupname) { List&amp;lt;UserPrincipal&amp;gt; result = new List&amp;lt;UserPrincipal&amp;gt;(); using (var context = new PrincipalContext(ContextType.Domain, domain)) using (var group = GroupPrincipal.FindByIdentity(context, groupname)) { if (group != null) { result.AddRange(group.GetMembers(true).Cast&amp;lt;UserPrincipal&amp;gt;().ToList()); } } return result; } private static string GetADStatus(int inputField) { // Assume the user is disabled string result = &amp;#34;Disabled&amp;#34;; // Declare the hex for the accountDisabled flag int accountDisabled = 0x00000002; // https://msdn.</description></item><item><title>C# - Read a .csv in .NET</title><link>https://blog.lukebtaylor.com/posts/c#-read-a-.csv-in-.net/</link><pubDate>Thu, 07 Jul 2016 22:11:44 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/c#-read-a-.csv-in-.net/</guid><description>// Namespace: Microsoft.VisualBasic.FileIO // https://msdn.microsoft.com/en-us/library/microsoft.visualbasic.fileio.textfieldparser%28v=vs.110%29.aspx // Assembly: Microsoft.VisualBasic (in Microsoft.VisualBasic.dll) private static List&amp;lt;SourceDocument&amp;gt; ReadCSV(string p) { List&amp;lt;SourceDocument&amp;gt; docs = new List&amp;lt;SourceDocument&amp;gt;(); using (TextFieldParser parser = new TextFieldParser(p)) { parser.TextFieldType = FieldType.Delimited; parser.SetDelimiters(&amp;#34;,&amp;#34;); while (!parser.EndOfData) { //Processing row string[] fields = parser.ReadFields(); if (fields[0].Trim().ToUpper() != &amp;#34;HEADER1NAME&amp;#34;) { SourceDocument doc = new SourceDocument(); doc.StringField = fields[0].Trim(); doc.IntField = Convert.ToInt32(fields[1]); doc.DateField = Convert.ToDateTime(fields[2]); docs.Add(doc); } } } return docs; }</description></item><item><title>C# - Task Patterns</title><link>https://blog.lukebtaylor.com/posts/c#-task-patterns/</link><pubDate>Thu, 07 Jul 2016 22:10:28 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/c#-task-patterns/</guid><description>Tasks
Get The Number of Logical Cores var logicalCoreCount = Environment.ProcessorCount; Wait All One By One List &amp;lt; Task &amp;lt;TResult&amp;gt;&amp;gt; tasks = new List &amp;lt; Task&amp;lt;TResult&amp;gt;&amp;gt; (); for (int i = 0; i &amp;lt; N; i++) // Start N tasks: { tasks.Add( Task.Factory.StartNew&amp;lt;TResult&amp;gt; (code) ); } while (tasks.Count &amp;gt; 0) { // Get the array index of the task that finishes first int index = Task.WaitAny( tasks.ToArray() ); // This will never throw an exception here // Catch the exception like this try { tasks[index].</description></item><item><title>C# - Enumerating a Registry Key Results in a Null Value</title><link>https://blog.lukebtaylor.com/posts/c#-enumerating-a-registry-key-results-in-a-null-value/</link><pubDate>Mon, 15 Feb 2016 22:11:16 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/c#-enumerating-a-registry-key-results-in-a-null-value/</guid><description>This post assumes .NET 4.0
After trying for some time to get a registry key to list all of its subkeys, I kept getting a null value back.
This code does not work It always returns null.
var keyName = @&amp;#34;SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid&amp;#34;; using (var guidSet = Registry.LocalMachine.OpenSubKey(keyName)) { if (guidSet != null) { foreach (var guid in guidSet.GetSubKeyNames()) { result.Add(guid); Console.WriteLine(&amp;#34;{0}&amp;#34;, guid); } } } This code works
var keyName = @&amp;#34;SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileGuid&amp;#34;; using (var hklm = RegistryKey.</description></item></channel></rss>