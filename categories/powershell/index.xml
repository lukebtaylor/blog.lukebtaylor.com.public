<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>powershell on Luke's blog site</title><link>https://blog.lukebtaylor.com/categories/powershell/</link><description>Recent content in powershell on Luke's blog site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Feb 2018 22:18:24 -0600</lastBuildDate><atom:link href="https://blog.lukebtaylor.com/categories/powershell/index.xml" rel="self" type="application/rss+xml"/><item><title>PowerShell - Get Current User</title><link>https://blog.lukebtaylor.com/posts/powershell-get-current-user/</link><pubDate>Fri, 02 Feb 2018 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-get-current-user/</guid><description># User Name Only $(Get-WMIObject -class Win32_ComputerSystem | select username).username [Environment]::UserName $env:username # Domain Name and User Name $(whoami) [System.Security.Principal.WindowsIdentity]::GetCurrent().Name # Domain [Environment]::UserDomainName # Machine Name [Environment]::MachineName</description></item><item><title>PowerShell - Suppress stderr output</title><link>https://blog.lukebtaylor.com/posts/powershell-suppress-stderr-output/</link><pubDate>Fri, 02 Feb 2018 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-suppress-stderr-output/</guid><description>stderr to null @ $commandWithArgs 2&amp;gt;&amp;amp;1 | out-null or
@ $commandWithArgs --quiet --no-verbose &amp;gt; $null 2&amp;gt;&amp;amp;1 all output to null @ $commandWithArgs *&amp;gt; | $null</description></item><item><title>Powershell - Update a certificate friendly name</title><link>https://blog.lukebtaylor.com/posts/powershell-update-a-certificate-friendly-name/</link><pubDate>Wed, 25 Oct 2017 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-update-a-certificate-friendly-name/</guid><description>function Legacy-UpdateFriendlyName { param( [parameter(Mandatory = $true, ValueFromPipeLine= $true)] [string]$Name, [parameter(Mandatory = $true)] [string]$FriendlyName, [ValidateSet(&amp;#34;FindByThumbprint&amp;#34;, &amp;#34;FindBySubjectName&amp;#34;, &amp;#34;FindBySubjectDistinguishedName&amp;#34;, &amp;#34;FindByIssuerName&amp;#34;, &amp;#34;FindByIssuerDistinguishedName&amp;#34;, &amp;#34;FindBySerialNumber&amp;#34;, &amp;#34;FindByTimeValid&amp;#34;, &amp;#34;FindByTimeNotYetValid&amp;#34;, &amp;#34;FindByTimeExpired&amp;#34;, &amp;#34;FindByTemplateName&amp;#34;, &amp;#34;FindByApplicationPolicy&amp;#34;, &amp;#34;FindByCertificatePolicy&amp;#34;, &amp;#34;FindByExtension&amp;#34;, &amp;#34;FindByKeyUsage&amp;#34;, &amp;#34;FindBySubjectKeyIdentifier&amp;#34;)] [string]$Type = &amp;#34;FindByThumbprint&amp;#34; ) $store = New-Object System.Security.Cryptography.X509Certificates.X509Store $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::MaxAllowed) Try { $certificates = $store.Certificates.Find($type,$name,$false) if( -not([string]::IsNullOrEmpty($certificates)) ) { foreach($cert in $certificates) { $cert.FriendlyName = $FriendlyName # + &amp;#34; - &amp;#34; + $cert.Subject #$cert } } else { Write-Warning &amp;#34;No Certificates found&amp;#34; } } Catch { $error[0] } $store.</description></item></channel></rss>