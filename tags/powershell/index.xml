<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>powershell on Luke's blog site</title><link>https://blog.lukebtaylor.com/tags/powershell/</link><description>Recent content in powershell on Luke's blog site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 02 Dec 2020 06:30:00 -0600</lastBuildDate><atom:link href="https://blog.lukebtaylor.com/tags/powershell/index.xml" rel="self" type="application/rss+xml"/><item><title>PowerShell - Exit Code</title><link>https://blog.lukebtaylor.com/posts/powershell-exit-code/</link><pubDate>Wed, 02 Dec 2020 06:30:00 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-exit-code/</guid><description>PowerShell - Exit Code $arg1Data = &amp;#34;someArgText&amp;#34;; $Proc = Start-Process -FilePath &amp;#34;some.exe&amp;#34; -ArgumentList @(&amp;#34;-arg1:$arg1Data&amp;#34;,&amp;#39;-someOtherSwitch&amp;#39;,&amp;#39;-anotherArg:someOtherText&amp;#39;,&amp;#34;someStaticTextThatIsAnArg&amp;#34;) -PassThru -Wait -NoNewWindow; if($Proc.ExitCode -ne 0) { Throw &amp;#34;Failed to execute with exitcode: $($Proc.ExitCode)&amp;#34;; } With Splatting $exe = &amp;#34;some.exe&amp;#34;; $arg1Data = &amp;#34;someOtherArgContent&amp;#34;; $cmdArgs = @( &amp;#34;-arg1:$arg1Data&amp;#34; ,&amp;#39;-someOtherSwitch&amp;#39; ,&amp;#39;-anotherArg:someOtherText&amp;#39; ,&amp;#34;someStaticTextThatIsAnArg&amp;#34; ); $parms = @{ &amp;#34;FilePath&amp;#34;=$exe; &amp;#34;ArgumentList&amp;#34;=$cmdArgs; &amp;#34;PassThru&amp;#34;=$true; &amp;#34;Wait&amp;#34;=$true; &amp;#34;NoNewWindow&amp;#34;=$true; } $Proc = Start-Process @parms; if($Proc.ExitCode -ne 0) { Throw &amp;#34;Failed to execute with exitcode: $($Proc.ExitCode)&amp;#34;; } https://docs.</description></item><item><title>PowerShell - Get Current User</title><link>https://blog.lukebtaylor.com/posts/powershell-get-current-user/</link><pubDate>Fri, 02 Feb 2018 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-get-current-user/</guid><description># User Name Only $(Get-WMIObject -class Win32_ComputerSystem | select username).username [Environment]::UserName $env:username # Domain Name and User Name $(whoami) [System.Security.Principal.WindowsIdentity]::GetCurrent().Name # Domain [Environment]::UserDomainName # Machine Name [Environment]::MachineName</description></item><item><title>PowerShell - Suppress stderr output</title><link>https://blog.lukebtaylor.com/posts/powershell-suppress-stderr-output/</link><pubDate>Fri, 02 Feb 2018 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-suppress-stderr-output/</guid><description>stderr to null @ $commandWithArgs 2&amp;gt;&amp;amp;1 | out-null or
@ $commandWithArgs --quiet --no-verbose &amp;gt; $null 2&amp;gt;&amp;amp;1 all output to null @ $commandWithArgs *&amp;gt; | $null</description></item><item><title>Powershell - Update a certificate friendly name</title><link>https://blog.lukebtaylor.com/posts/powershell-update-a-certificate-friendly-name/</link><pubDate>Wed, 25 Oct 2017 22:18:24 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/powershell-update-a-certificate-friendly-name/</guid><description>function Legacy-UpdateFriendlyName { param( [parameter(Mandatory = $true, ValueFromPipeLine= $true)] [string]$Name, [parameter(Mandatory = $true)] [string]$FriendlyName, [ValidateSet(&amp;#34;FindByThumbprint&amp;#34;, &amp;#34;FindBySubjectName&amp;#34;, &amp;#34;FindBySubjectDistinguishedName&amp;#34;, &amp;#34;FindByIssuerName&amp;#34;, &amp;#34;FindByIssuerDistinguishedName&amp;#34;, &amp;#34;FindBySerialNumber&amp;#34;, &amp;#34;FindByTimeValid&amp;#34;, &amp;#34;FindByTimeNotYetValid&amp;#34;, &amp;#34;FindByTimeExpired&amp;#34;, &amp;#34;FindByTemplateName&amp;#34;, &amp;#34;FindByApplicationPolicy&amp;#34;, &amp;#34;FindByCertificatePolicy&amp;#34;, &amp;#34;FindByExtension&amp;#34;, &amp;#34;FindByKeyUsage&amp;#34;, &amp;#34;FindBySubjectKeyIdentifier&amp;#34;)] [string]$Type = &amp;#34;FindByThumbprint&amp;#34; ) $store = New-Object System.Security.Cryptography.X509Certificates.X509Store $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::MaxAllowed) Try { $certificates = $store.Certificates.Find($type,$name,$false) if( -not([string]::IsNullOrEmpty($certificates)) ) { foreach($cert in $certificates) { $cert.FriendlyName = $FriendlyName # + &amp;#34; - &amp;#34; + $cert.Subject #$cert } } else { Write-Warning &amp;#34;No Certificates found&amp;#34; } } Catch { $error[0] } $store.</description></item><item><title>Windows - Changing a network interface profile to Private</title><link>https://blog.lukebtaylor.com/posts/windows-changing-a-network-interface-profile-to-private/</link><pubDate>Sun, 05 Jun 2016 22:11:44 -0600</pubDate><guid>https://blog.lukebtaylor.com/posts/windows-changing-a-network-interface-profile-to-private/</guid><description>Isn&amp;rsquo;t Windows Easy? Changing a network interface profile to Private
Windows interfaces kind of suck.
Let&amp;rsquo;s change one from whatever Windows decided to allocate it to and make it into a Private interface.
First, let&amp;rsquo;s take a look at all of the interfaces on the machine.
netsh interface ip show interfaces This is great, but the PowerShell commands we are going to use will only alllow us to change active connections.</description></item></channel></rss>